from numbers import Integral
import numpy as np
import tempfile
import logging
import shutil
from branchedflowsim import config
from branchedflowsim.potential import Potential

_logger = logging.getLogger(__name__)


class MediumSpec(object):
    """
    A `MediumSpec` defines the specifications of a random medium.
    It allows to create different realizations of the medium
    fulfilling these specifications.

    It does not include technical specifications like number of
    threads that will be used to generate it.

    Each medium spec defines its support, the physical range
    on which it is defined. It also has a shape, which defines
    the resolution, i.e. the number of steps into which the
    support is divided.
    """
    def __init__(self, shape, strength, support=None):
        """
        An abstract `MediumSpec` for a medium of given `strength`,
        on some `support`, with a resolution of `shape`.
        
        :param shape: The shape of the array data that will be used to describe realizations of this medium.
        :param strength: The strength of this medium (i.e. a prefactor that dictates how strongly rays are
                         influenced by this medium).
        :param support: The (mathematical) support on which the medium will be defined.
        """
        if support is None:
            support = np.ones_like(shape)

        if len(shape) != len(support):
            raise ValueError("Different dimension in shape (%s) and support (%s)" % (shape, support))

        self._shape = tuple(shape)
        self._support = np.array(support)
        self._strength = strength

    @property
    def shape(self):
        return self._shape

    @property
    def strength(self):
        return self._strength

    @property
    def dimension(self):
        return len(self.shape)

    @property
    def support(self):
        return self._support

    def create(self, file_name, seed=None, options=None):
        """
        Create a realization of that medium and save it to `save_file`.
        Use `seed` for ensuring consistent randomness, where `None` means a random seed.
        :param str file_name: Path to the file where the generated medium should be saved.
        :param int seed: Seed for the random number generator.
        :param dict options: Additional options that influence the generation of the potential. \
               These should be options of technical nature (e.g. number of threads to use) that do \
               not change the physical interpretation of the result.
        :returns A Potential that references the newly created file.
        :rtype: Potential
        """
        raise NotImplementedError()

    @property
    def as_dict(self):
        """
        Returns the parameters of the MediumSpec as a dictionary, so that they may be saved into a json file. Derived 
        classes should override the `_params_as_dict` property.
        """
        return {"type": self.__class__.__name__, "params": self._params_as_dict}

    @property
    def _params_as_dict(self):
        """
        Converts the parameters of the MediumSpec into a serializable dict.
        :return: The parameters as dict.
        """
        return {"shape": self.shape, "strength": self.strength, "support": self.support, "dimension": self.dimension}

    @staticmethod
    def from_dict(data):
        """
        Reconstructs the MediumSpec from the dict representation. This function performs the type dispatch,
        the actual loading is implemented in `_from_dict` which should be overwritten in derived classes.
        :param data: A dictionary with the same structure as returned by `as_dict`. 
        :return: A new MediumSpec object.
        """
        spec_class = data["type"]
        for sub in MediumSpec.__subclasses__():
            if sub.__name__ == spec_class:
                return sub._from_dict(data["params"])
        raise TypeError("Could not find '%s' subclass of 'MediumSpec'" % spec_class)

    @classmethod
    def _from_dict(cls, params):
        """
        Implementation of the from dict function. Overwrite this in derived classes.
        :param params: The parameter dict as produced by `as_dict`.
        :return: The create MediumSpec.
        """
        return MediumSpec(params["shape"], params["strength"], params["support"])

    def __repr__(self):
        if all(self.support == self.support[0]):
            supp = "[0, %s]^%s" % (self.support[0], self.dimension)
        else:
            supp = "x".join(["[0, %s]" % s for s in self.support])
        return "<MediumSpec on %s (%s)>" % (supp, "x".join(map(str, self.shape)))


class ScalarPotentialSpec(MediumSpec):
    """
    A potential spec for the scalar potential
    generated by the "potgen" programme.
    """
    def __init__(self, size_or_shape, dimension, correlation, strength, support=None):
        """
        Create a new scalar potential.
        
        :param int|Sequence[int] size_or_shape: Either a single int as a size parameter, or multiple ints defining the
                                                complete shape.
        :param Optional[int] dimension: Dimension of medium. Can be `None` if a complete shape is specified.
        :param Correlation correlation: Correlation function.
        :param float strength: The strength of the random potential.
        :param np.ndarray support: The support on which the potential will be defined. Default to the unit cube.
        :raises ValueError: If `dimension` contradicts the number of elements in `size_or_shape`.
        """
        if isinstance(size_or_shape, Integral):
            size_or_shape = (size_or_shape,) * dimension

        if dimension is not None and len(size_or_shape) != dimension:
            raise ValueError("Shape (%s) does not conform to dimension %s" % (size_or_shape, dimension))

        super(ScalarPotentialSpec, self).__init__(size_or_shape, strength, support)

        self._correlation = correlation

    @property
    def _params_as_dict(self):
        """
        Converts the parameters of the MediumSpec into a serializable dict.
        :return: The parameters as dict.
        """
        pdict = super(ScalarPotentialSpec, self)._params_as_dict
        pdict["correlation"] = self._correlation.as_dict
        return pdict

    @classmethod
    def _from_dict(cls, params):
        """
        Implementation of the from dict function. Overwrite this in derived classes.
        :param params: The parameter dict as produced by `as_dict`.
        :return: The create MediumSpec.
        """
        from branchedflowsim.correlation import Correlation
        return ScalarPotentialSpec(params["shape"], params["dimension"], Correlation.from_dict(params["correlation"]),
                                   params["strength"], params["support"])

    @property
    def correlation(self):
        return self._correlation

    def create(self, file_name, seed=None, options=None):
        from branchedflowsim.potgen import generate
        if options is None:
            options = {}
        generate(file_name, self.dimension, self.shape, self.correlation, self.strength, seed, **options)
        return Potential.from_file(file_name)


def generate_multiple(spec, repeat, options=None, work_dir=None):
    """
    Generate multiple realizations of a given `MediumSpec`.

    :param MediumSpec spec: Specification for the medium.
    :param int repeat: The number of potential realizations to use.
    :param str work_dir: A directory in which all files will be created.
                         If `None` uses `branchedflowsim.config.DEFAULT_WORKDIR`.
    :param Optional[dict] options: Options to be passed tp the `create` function of the potential.

    :return: A generator for the created potentials.
    """
    if options is None:
        options = {}

    work_dir = config.get_workdir(work_dir)
    with tempfile.NamedTemporaryFile(dir=work_dir) as f:
        _logger.info("Generating %d potentials in temporary file %s", repeat, f.name)
        for n in range(repeat):
            yield spec.create(f.name, options=options)
