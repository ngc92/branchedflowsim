// define the modules in which the documentation is grouped

/*! \defgroup common Common Module
	A static library that contains multi purpose code used by different subprojects. This includes 
	multi-dimensional data grids, interpolation algorithms, and file io operations.
*/

namespace init_cond
{
/*!
    \page ic_doc initial condition generation
    Abstractly speaking, an initial condition defines a submanifold in phase space. To generate initial ray
    states we then sample from that manifold. This is managed by the InitialConditionGenerator class, which
    provides the common framework for the generation. Subclasses then can implement the concrete way in which
    the submanifold is sampled.

    Iterating over all initial rays is done using the InitialCondition class, which implements an iterator-like
    interface for IC generation. It allows direct access to the properties of the current ray, and implements
    InitialCondition::operator++ to get the next, and operator bool to check if there are still rays
    left.

    In order to easily parallelize the ray tracer, iterating over the initial conditions is implemented in a thread
    safe way, i.e. we can create one InitialCondition object per thread, and iterate over those in their respective
    threads to get all initial rays exactly once.

    The process of generating a new initial condition runs as follows.
    First, the InitialConditionGenerator object is created, and initialized (InitialConditionGenerator::init) with
    the desired configuration. At this point, the InitialConditionGenerator::init_generator function is called,
    which can be overridden by derived classes. Its responsibility is to set the ManifoldIndex, which is a
    MultiIndex used to iterate over discrete positions on the manifold. If you want uniform sampling on the unit
    square, the default implementation will suffice.

    After the initialization, calling InitialConditionGenerator::next() will give an iterator over the ICs. Calling
    next multiple times will generate multiple iterators, that collectively iterate the ICs once. To simple iterate
    over all ICs, use the iterator interface provided by InitialCondition to prevent reallocating memory.
    Multiple InitialCondition objects are useful for iterating in multiple threads. In the following `iterator` will
    always denote an InitialCondition object.

    To get new initial condition data, `iterator` calls (in its constructor and operator++) the
    InitialConditionGenerator::advance() function, which is responsible for creating new ray coordinates in a
    thread-save manner. This is done using the following steps:

     -  First, the  \ref InitialConditionGenerator::next_trajectory "next_trajectory" function is called,
        which is a customization point where derived classes can to
        work that modifies the entire process of generating the initial condition. For example, random generators
        can choose a new reference point here.
     -  Then, the \ref InitialConditionGenerator::generateNormalized "generateNormalized" function is called
        for the actual manifold position. This function in turn
        calls the actual generate function of the derived class, which fills in the initial state of the ray.
        Further, generateNormalized applies energy normalization and coordinate scaling (note that this scales the
        positions but leaves the velocities unchanged). First the coordinates are scaled to fill the given support,
        then the offset is applied (i.e. the offset is given in the scaled coordinate system). As the last step
        the energy is normalized.
     -  Finally, to support caustic detection, we also need the partial derivatives of the initial state with
        respect to the initial manifold coordinates. These are generated numerically by calling
        \ref InitialConditionGenerator::generateNormalized "generateNormalized" again for small displacements in the
        original manifold position.

    Tests for the generic InitialCondition interface can be found in `src/tracer/test/init_cond_tests.cpp`.

    The following implementations for initial conditions are available:
     - PlanarWave
     - RandomPlanar
     - RadialWave2D
     - RadialWave3D
     - RandomRadial
     - GenericCaustic2D
*/

}

/*!
    \page python_api_doc Python API
    An autogenerated api doc for the python binding can be found
    <a href="../python-api/html/index.html">here</a>
*/